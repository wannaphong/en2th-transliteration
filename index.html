<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart EN-TH Transliteration</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        /* [Keeping your previous CSS styles...] */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        input[type="text"] { flex-grow: 1; padding: 12px; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc; }
        button { padding: 12px 20px; font-size: 1rem; border-radius: 4px; border: none; background: #28a745; color: white; cursor: pointer; }
        button:hover { background: #218838; }
        .full-sentence-result { padding: 20px; background: #e3f2fd; border-radius: 8px; border: 1px solid #90caf9; margin-bottom: 20px; }
        .result-text { font-size: 1.8rem; color: #0056b3; font-weight: bold; }
        .container { display: flex; flex-wrap: wrap; gap: 10px; }
        .word-block { background: white; border: 1px solid #ddd; padding: 10px 15px; border-radius: 8px; }
        .syllable { background: #f0f2f5; color: #444; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem; margin-right:2px; }
        .thai-output { font-size: 1.2rem; color: #28a745; font-weight: bold; margin-top: 5px; }
    </style>
</head>
<body>

    <h2>Smart Transliteration (Bi-GRU + Attention)</h2>
    
    <div class="input-group">
        <input type="text" id="inputText" placeholder="e.g. christopher nolan" onkeydown="if(event.key==='Enter') runPipeline()">
        <button onclick="runPipeline()">Smart Convert</button>
    </div>

    <div class="controls">
        <label><input type="checkbox" id="sylToggle" checked> Show Syllables</label>
        <span id="status" style="margin-left: 10px; color: #888;">Loading models...</span>
    </div>

    <div class="full-sentence-result">
        <div style="font-size: 0.8rem; color: #555;">FULL RESULT</div>
        <div id="finalOutput" class="result-text">...</div>
    </div>

    <div id="breakdownContainer" class="container"></div>

    <script>
        // PASTE YOUR NEW JSON VOCAB HERE
        const VOCAB_DATA ={"input_char2idx": {"<PAD>": 0, "<SOS>": 1, "<EOS>": 2, "<UNK>": 3, "a": 4, "r": 5, "e": 6, "b": 7, "c": 8, "d": 9, "f": 10, "g": 11, "h": 12, "i": 13, "j": 14, "k": 15, "l": 16, "m": 17, "n": 18, "o": 19, "p": 20, "q": 21, "s": 22, "t": 23, "u": 24, "v": 25, "x": 26, "y": 27, "z": 28, "w": 29, "-": 30, " ": 31, "é": 32, "'": 33, "ฺ": 34, "è": 35, ".": 36, "1": 37, "7": 38, "3": 39, "9": 40, "–": 41, "\"": 42, "+": 43, "/": 44, "4": 45, "8": 46, "6": 47, "2": 48, "0": 49}, "target_idx2char": {"0": "<PAD>", "1": "<SOS>", "2": "<EOS>", "3": "<UNK>", "4": "อ", "5": "า", "6": "ะ", "7": "บ", "8": "ี", "9": "ซ", "10": "ด", "11": "เ", "12": "ฟ", "13": "จ", "14": "ช", "15": "ไ", "16": "ค", "17": "แ", "18": "ล", "19": "็", "20": "ม", "21": "น", "22": "โ", "23": "พ", "24": "ิ", "25": "ว", "26": "ร", "27": "์", "28": "ส", "29": "ท", "30": "ย", "31": "ู", "32": "ก", "33": "ต", "34": "ป", "35": "่", "36": "ั", "37": "ง", "38": "้", "39": "ฮ", "40": "๊", "41": "ถ", "42": "ห", "43": "ธ", "44": "ึ", "45": "ุ", "46": "ศ", "47": "ฤ", "48": "ษ", "49": "ฎ", "50": "๋", "51": " ", "52": "ำ", "53": "ฉ", "54": "1", "55": "ญ", "56": "-", "57": "ฃ", "58": "9", "59": "3", "60": "ฌ", "61": "y", "62": "l", "63": "o", "64": "n", "65": "ข", "66": "ฝ", "67": "'", "68": "ฺ", "69": "ื", "70": "ใ", "71": "/", "72": "ฯ", "73": "ๆ", "74": "`", "75": "ณ", "76": "๎", "77": ":", "78": "*", "79": "ผ"}};

        const MAX_LEN = 25;
        let encSession, decSession;

        // --- TOKENIZERS ---
        function tokenizeWords(sentence) { return sentence.trim().split(/\s+/); }
        function tokenizeSyllables(word) {
            word = word.toLowerCase();
            if (word.length <= 3) return [word];
            const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi;
            return word.match(syllableRegex) || [word];
        }

        // --- LOAD MODELS ---
        async function loadModels() {
            try {
                const option = { executionProviders: ['wasm'] }; 
                // Note: File names changed to _attn.onnx
                encSession = await ort.InferenceSession.create('./v9-encoder_attn.onnx', option);
                decSession = await ort.InferenceSession.create('./v9-decoder_attn.onnx', option);
                document.getElementById('status').innerText = "Smart Models Ready";
                document.getElementById('status').style.color = "green";
            } catch (e) {
                document.getElementById('status').innerText = "Load Error: " + e;
                console.error(e);
            }
        }
        loadModels();

        // --- SMART INFERENCE LOGIC ---
        async function transliterateWord(word) {
            word = word.toLowerCase();
            try {
                // 1. Encode Input
                const srcIndices = [1]; 
                for (let char of word) srcIndices.push(VOCAB_DATA.input_char2idx[char] || 3);
                srcIndices.push(2);

                const srcTensor = new ort.Tensor('int64', BigInt64Array.from(srcIndices.map(x => BigInt(x))), [1, srcIndices.length]);
                
                // 2. Run Encoder
                // Returns: { encoder_outputs, hidden }
                const encResults = await encSession.run({ src: srcTensor });
                
                // We must keep these for the decoder loop
                const encoderOutputs = encResults.encoder_outputs; 
                let hidden = encResults.hidden;

                // 3. Decoder Loop
                let currTokenIdx = 1n; // <SOS>
                let decodedStr = "";

                for (let i = 0; i < MAX_LEN; i++) {
                    // Decoder Inputs: input, hidden, encoder_outputs
                    const decFeeds = {
                        input: new ort.Tensor('int64', BigInt64Array.from([currTokenIdx]), [1]),
                        hidden: hidden,
                        encoder_outputs: encoderOutputs // Pass attention features every step
                    };

                    const decResults = await decSession.run(decFeeds);
                    
                    // Update state
                    hidden = decResults.new_hidden;
                    const logits = decResults.prediction.data;

                    // Argmax
                    let bestIdx = 0;
                    let maxVal = -Infinity;
                    for (let j = 0; j < logits.length; j++) {
                        if (logits[j] > maxVal) { maxVal = logits[j]; bestIdx = j; }
                    }

                    if (bestIdx === 2) break; // EOS
                    if (bestIdx > 3) decodedStr += (VOCAB_DATA.target_idx2char[bestIdx] || "");
                    currTokenIdx = BigInt(bestIdx);
                }
                return decodedStr;
            } catch (e) {
                console.error("Error:", word, e);
                return "Error";
            }
        }

        // --- PIPELINE ---
        async function runPipeline() {
            const sentence = document.getElementById('inputText').value;
            if (!sentence || !encSession) return;

            const container = document.getElementById('breakdownContainer');
            const showSyllables = document.getElementById('sylToggle').checked;
            container.innerHTML = "";
            document.getElementById('finalOutput').innerText = "...";

            const words = tokenizeWords(sentence);
            const finalResults = [];

            for (let word of words) {
                const thaiWord = await transliterateWord(word);
                finalResults.push(thaiWord);

                const wordBlock = document.createElement('div');
                wordBlock.className = 'word-block';
                
                let middleContent = "";
                if (showSyllables) {
                    const syllables = tokenizeSyllables(word);
                    middleContent = `<div style="margin:4px 0">${syllables.map(s => `<span class="syllable">${s}</span>`).join('')}</div>`;
                }

                wordBlock.innerHTML = `<div style="font-weight:600;color:#666">${word}</div>${middleContent}<div class="thai-output">${thaiWord}</div>`;
                container.appendChild(wordBlock);
            }

            document.getElementById('finalOutput').innerText = finalResults.join(' ');
        }
    </script>
</body>
</html>