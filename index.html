<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>English to Thai Transliteration</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        input, button { padding: 12px; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc; }
        input { width: 60%; }
        button { background: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background: #0056b3; }
        
        .container { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        
        /* Word Block Style */
        .word-block { background: white; border: 1px solid #ddd; padding: 10px; border-radius: 8px; display: flex; flex-direction: column; gap: 5px; }
        .word-header { font-size: 0.8rem; color: #888; font-weight: bold; text-transform: uppercase; }
        
        .syllable-container { display: flex; gap: 5px; flex-wrap: wrap; }
        .syllable { background: #e2e6ea; color: #333; padding: 2px 8px; border-radius: 4px; font-size: 0.9rem; border: 1px solid #ced4da; }
        
        .thai-output { font-size: 1.4rem; color: #007bff; font-weight: bold; }
        
        .full-sentence-result { margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border: 1px solid #90caf9; }
        .loading { color: #888; font-size: 0.9rem; margin-top: 10px; }
    </style>
</head>
<body>

    <h2>EN-TH Sentence Transliteration</h2>
    
    <div>
        <input type="text" id="inputText" placeholder="e.g. hello world" onkeydown="if(event.key==='Enter') runPipeline()">
        <button onclick="runPipeline()">Convert</button>
    </div>
    
    <div id="status" class="loading">Loading models...</div>

    <div class="full-sentence-result">
        <div style="font-size: 0.8rem; color: #555; margin-bottom: 5px;">FULL SENTENCE</div>
        <div id="finalOutput" style="font-size: 1.8rem; color: #0056b3; font-weight: bold;">...</div>
    </div>

    <div id="breakdownContainer" class="container"></div>

    <script>
        // --- 1. CONFIGURATION ---
        const VOCAB_DATA = {
            "input_char2idx": {
                '<PAD>': 0, '<SOS>': 1, '<EOS>': 2, '<UNK>': 3,
                'a': 4, 'c': 5, 't': 6, 'i': 7, 'o': 8, 'n': 9, 'v': 10, 'e': 11,
                'd': 12, 'p': 13, 'r': 14, 'l': 15, 'b': 16, 'u': 17, 'm': 18, 'h': 19,
                'g': 20, 's': 21, 'k': 22, 'y': 23, 'x': 24, 'f': 25, 'w': 26, 'j': 27,
                'z': 28, 'q': 29, '-': 30, ' ': 31, 'é': 32, "'": 33, 'ฺ': 34, 'è': 35,
                '岸': 36, '田': 37, '文': 38, '雄': 39, '.': 40, '1': 41, '7': 42, '3': 43,
                '9': 44, '–': 45
            },
            "target_idx2char": {
                "0": "<PAD>", "1": "<SOS>", "2": "<EOS>", "3": "<UNK>",
                "4": "แ", "5": "อ", "6": "ค", "7": "ช", "8": "ั", "9": "่", "10": "น",
                "11": "ท", "12": "ี", "13": "ฟ", "14": "ะ", "15": "ด", "16": "ป", "17": "เ",
                "18": "ต", "19": "ร", "20": "์", "21": "ล", "22": "บ", "23": "้", "24": "ม",
                "25": "ก", "26": "ฮ", "27": "า", "28": "ิ", "29": "ึ", "30": "พ", "31": "ส",
                "32": "ซ", "33": "โ", "34": "็", "35": "ง", "36": "ุ", "37": "๊", "38": "ู",
                "39": "ว", "40": "ไ", "41": "ย", "42": "จ", "43": "ห", "44": "ศ", "45": "ธ",
                "46": "ฤ", "47": "ษ", "48": "ฎ", "49": "๋", "50": " ", "51": "ำ", "52": "ถ",
                "53": "ฉ", "54": "1", "55": "ญ", "56": "-", "57": "ฃ", "58": "9", "59": "3",
                "60": "ฌ", "61": "y", "62": "l", "63": "o", "64": "n", "65": "ข", "66": "ฝ"
            }
        };

        const MAX_LEN = 20;
        let encSession, decSession;

        // --- 2. TOKENIZERS ---
        
        // A. Word Tokenizer (Splits by spaces)
        function tokenizeWords(sentence) {
            // Trim and split by one or more spaces
            return sentence.trim().split(/\s+/);
        }

        // B. Syllable Tokenizer (Splits individual words)
        function tokenizeSyllables(word) {
            word = word.toLowerCase();
            if (word.length <= 3) return [word];
            if (word.slice(-2) === 'le' && !['a','e','i','o','u'].includes(word.slice(-3, -2))) {
                const main = word.slice(0, -2);
                return [...tokenizeSyllables(main), 'le'];
            }
            const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi;
            let syllables = word.match(syllableRegex) || [word];
            const joined = syllables.join('');
            if (joined.length < word.length) {
                syllables[syllables.length - 1] += word.slice(joined.length);
            }
            return syllables;
        }

        // --- 3. MODEL LOADING ---
        async function loadModels() {
            try {
                const option = { executionProviders: ['wasm'] }; 
                encSession = await ort.InferenceSession.create('./v4-encoder.onnx', option);
                decSession = await ort.InferenceSession.create('./v4-decoder.onnx', option);
                document.getElementById('status').innerText = "Models Loaded! Ready.";
            } catch (e) {
                document.getElementById('status').innerText = "Error: " + e;
            }
        }
        loadModels();

        // --- 4. CORE INFERENCE (Single Word) ---
        async function transliterateWord(word) {
            word = word.toLowerCase();
            try {
                // Encode
                const srcIndices = [1]; 
                for (let char of word) srcIndices.push(VOCAB_DATA.input_char2idx[char] || 3);
                srcIndices.push(2);

                const srcTensor = new ort.Tensor('int64', BigInt64Array.from(srcIndices.map(x => BigInt(x))), [1, srcIndices.length]);
                
                const encResults = await encSession.run({ src: srcTensor });
                const context = encResults.context;

                // Decode
                let hidden = context;
                let currTokenIdx = 1n;
                let decodedStr = "";

                for (let i = 0; i < MAX_LEN; i++) {
                    const decResults = await decSession.run({
                        input: new ort.Tensor('int64', BigInt64Array.from([currTokenIdx]), [1]),
                        hidden: hidden,
                        context: context
                    });
                    
                    hidden = decResults.new_hidden;
                    const logits = decResults.prediction.data;

                    let bestIdx = 0;
                    let maxVal = -Infinity;
                    for (let j = 0; j < logits.length; j++) {
                        if (logits[j] > maxVal) { maxVal = logits[j]; bestIdx = j; }
                    }

                    if (bestIdx === 2) break; // EOS
                    if (bestIdx > 3) decodedStr += (VOCAB_DATA.target_idx2char[bestIdx] || "");
                    currTokenIdx = BigInt(bestIdx);
                }
                return decodedStr;
            } catch (e) {
                console.error("Error processing word:", word, e);
                return "???";
            }
        }

        // --- 5. MAIN PIPELINE ---
        async function runPipeline() {
            const sentence = document.getElementById('inputText').value;
            if (!sentence || !encSession) return;

            const container = document.getElementById('breakdownContainer');
            container.innerHTML = ""; // Clear previous
            document.getElementById('finalOutput').innerText = "...";

            // Step A: Word Tokenization
            const words = tokenizeWords(sentence);
            const finalResults = [];

            // Process each word individually
            for (let word of words) {
                // 1. Syllable Tokenization (For Display)
                const syllables = tokenizeSyllables(word);
                
                // 2. Inference (Async)
                const thaiWord = await transliterateWord(word);
                finalResults.push(thaiWord);

                // 3. Render Block
                const wordBlock = document.createElement('div');
                wordBlock.className = 'word-block';
                
                const sylHtml = syllables.map(s => `<span class="syllable">${s}</span>`).join('');
                
                wordBlock.innerHTML = `
                    <div class="word-header">Source: ${word}</div>
                    <div class="syllable-container">${sylHtml}</div>
                    <div class="thai-output">${thaiWord}</div>
                `;
                container.appendChild(wordBlock);
            }

            // Step B: Join Final Sentence
            document.getElementById('finalOutput').innerText = finalResults.join(' ');
        }
    </script>
</body>
</html>