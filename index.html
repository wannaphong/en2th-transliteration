<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart EN-TH Transliteration</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        /* [Keeping your previous CSS styles...] */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        input[type="text"] { flex-grow: 1; padding: 12px; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc; }
        button { padding: 12px 20px; font-size: 1rem; border-radius: 4px; border: none; background: #28a745; color: white; cursor: pointer; }
        button:hover { background: #218838; }
        .full-sentence-result { padding: 20px; background: #e3f2fd; border-radius: 8px; border: 1px solid #90caf9; margin-bottom: 20px; }
        .result-text { font-size: 1.8rem; color: #0056b3; font-weight: bold; }
        .container { display: flex; flex-wrap: wrap; gap: 10px; }
        .word-block { background: white; border: 1px solid #ddd; padding: 10px 15px; border-radius: 8px; }
        .syllable { background: #f0f2f5; color: #444; padding: 2px 6px; border-radius: 4px; font-size: 0.85rem; margin-right:2px; }
        .thai-output { font-size: 1.2rem; color: #28a745; font-weight: bold; margin-top: 5px; }
    </style>
</head>
<body>

    <h2>Smart Transliteration</h2>
    
    <div class="input-group">
        <input type="text" id="inputText" placeholder="e.g. christopher nolan" onkeydown="if(event.key==='Enter') runPipeline()">
        <button onclick="runPipeline()">Smart Convert</button>
    </div>

    <div class="controls">
        <label><input type="checkbox" id="sylToggle" checked> Show Syllables</label>
        <span id="status" style="margin-left: 10px; color: #888;">Loading models...</span>
    </div>

    <div class="full-sentence-result">
        <div style="font-size: 0.8rem; color: #555;">FULL RESULT</div>
        <div id="finalOutput" class="result-text">...</div>
    </div>

    <div id="breakdownContainer" class="container"></div>

    <script>
        // PASTE YOUR NEW JSON VOCAB HERE
        const VOCAB_DATA ={"input_char2idx": {"<PAD>": 0, "<SOS>": 1, "<EOS>": 2, "<UNK>": 3, "a": 4, "r": 5, "e": 6, "b": 7, "c": 8, "d": 9, "f": 10, "g": 11, "h": 12, "i": 13, "j": 14, "k": 15, "l": 16, "m": 17, "n": 18, "o": 19, "p": 20, "q": 21, "s": 22, "t": 23, "u": 24, "v": 25, "x": 26, "y": 27, "z": 28, "w": 29, "-": 30, " ": 31, "\u00e9": 32, "'": 33, "\u0e3a": 34, "\u00e8": 35, ".": 36, "1": 37, "7": 38, "3": 39, "9": 40, "\u2013": 41, "\"": 42, "+": 43, "/": 44, "4": 45, "8": 46, "6": 47, "2": 48, "0": 49}, "target_idx2char": {"0": "<PAD>", "1": "<SOS>", "2": "<EOS>", "3": "<UNK>", "4": "\u0e2d", "5": "\u0e32", "6": "\u0e30", "7": "\u0e1a", "8": "\u0e35", "9": "\u0e0b", "10": "\u0e14", "11": "\u0e40", "12": "\u0e1f", "13": "\u0e08", "14": "\u0e0a", "15": "\u0e44", "16": "\u0e04", "17": "\u0e41", "18": "\u0e25", "19": "\u0e47", "20": "\u0e21", "21": "\u0e19", "22": "\u0e42", "23": "\u0e1e", "24": "\u0e34", "25": "\u0e27", "26": "\u0e23", "27": "\u0e4c", "28": "\u0e2a", "29": "\u0e17", "30": "\u0e22", "31": "\u0e39", "32": "\u0e01", "33": "\u0e15", "34": "\u0e1b", "35": "\u0e48", "36": "\u0e31", "37": "\u0e07", "38": "\u0e49", "39": "\u0e2e", "40": "\u0e4a", "41": "\u0e16", "42": "\u0e2b", "43": "\u0e18", "44": "\u0e36", "45": "\u0e38", "46": "\u0e28", "47": "\u0e24", "48": "\u0e29", "49": "\u0e0e", "50": "\u0e4b", "51": " ", "52": "\u0e33", "53": "\u0e09", "54": "1", "55": "\u0e0d", "56": "-", "57": "\u0e03", "58": "9", "59": "3", "60": "\u0e0c", "61": "y", "62": "l", "63": "o", "64": "n", "65": "\u0e02", "66": "\u0e1d", "67": "'", "68": "\u0e3a", "69": "\u0e37", "70": "\u0e43", "71": "/", "72": "\u0e2f", "73": "\u0e46", "74": "`", "75": "\u0e13", "76": "\u0e4e", "77": ":", "78": "*", "79": "\u0e1c"}};

        const MAX_LEN = 50; 
        let encSession, decSession;

        // --- TOKENIZERS ---
        function tokenizeWords(sentence) { return sentence.trim().split(/\s+/); }
        function tokenizeSyllables(word) {
            word = word.toLowerCase();
            if (word.length <= 3) return [word];
            const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi;
            return word.match(syllableRegex) || [word];
        }

        // --- LOAD MODELS ---
        async function loadModels() {
            try {
                const option = { executionProviders: ['wasm'] }; 
                // Note: File names changed to _attn.onnx
                encSession = await ort.InferenceSession.create('./v10-tf_encoder_fixed.onnx', option);
                decSession = await ort.InferenceSession.create('./v10-tf_decoder_fixed.onnx', option);
                document.getElementById('status').innerText = "Smart Models Ready";
                document.getElementById('status').style.color = "green";
            } catch (e) {
                document.getElementById('status').innerText = "Load Error: " + e;
                console.error(e);
            }
        }
        loadModels();

        // --- SMART INFERENCE LOGIC ---

        // --- SMART INFERENCE LOGIC (FIXED LENGTH) ---
        async function transliterateWord(word) {
            word = word.toLowerCase();
            try {
                // ==========================================
                // 1. ENCODER: Pad to Fixed Length 50
                // ==========================================
                let srcIndices = [1]; // SOS
                for (let char of word) {
                    srcIndices.push(VOCAB_DATA.input_char2idx[char] || 3);
                }
                srcIndices.push(2); // EOS

                // PAD WITH ZEROS UP TO 50
                const padLen = MAX_LEN - srcIndices.length;
                if (padLen > 0) {
                    for(let k=0; k<padLen; k++) srcIndices.push(0);
                } else {
                    srcIndices = srcIndices.slice(0, MAX_LEN); // Truncate if too long
                }

                // Create Tensor [1, 50]
                const srcTensor = new ort.Tensor(
                    'int64', 
                    BigInt64Array.from(srcIndices.map(x => BigInt(x))), 
                    [1, MAX_LEN]
                );
                
                // Run Encoder
                const encOut = await encSession.run({ src: srcTensor });
                const memory = encOut.memory; // Shape [1, 50, hidden]

                // ==========================================
                // 2. DECODER: Use Fixed Buffer of 50
                // ==========================================
                // Initialize buffer: [SOS, 0, 0, 0, ...]
                let tokenBuffer = new Array(MAX_LEN).fill(0);
                tokenBuffer[0] = 1; // SOS at start
                
                let currentIdx = 0; // Pointer to current step
                let decodedStr = "";

                // We only loop 25 times for output generation
                for (let i = 0; i < 25; i++) {
                    // Create Decoder Input Tensor [1, 50]
                    const trgTensor = new ort.Tensor(
                        'int64', 
                        BigInt64Array.from(tokenBuffer.map(x => BigInt(x))), 
                        [1, MAX_LEN]
                    );
                    
                    const decOut = await decSession.run({ 
                        trg: trgTensor, 
                        memory: memory 
                    });

                    // Output is [1, 50, vocab_size] (Flattened Float32Array)
                    const outputData = decOut.prediction.data;
                    
                    // We need the vocab size to find the slice for the CURRENT index
                    // vocab_size = total_elements / 50
                    const vocabSize = outputData.length / MAX_LEN;
                    
                    // Calculate start index for the logits of the current step
                    // If currentIdx is 0 (we just fed SOS), we want prediction for index 0? 
                    // No, usually Transformer output at pos 0 predicts pos 1. 
                    // Let's grab the logits at 'currentIdx'
                    const startIndex = currentIdx * vocabSize;
                    
                    let bestIdx = 0;
                    let maxVal = -Infinity;
                    
                    // Argmax on the specific slice
                    for (let j = 0; j < vocabSize; j++) {
                        const val = outputData[startIndex + j];
                        if (val > maxVal) { maxVal = val; bestIdx = j; }
                    }

                    if (bestIdx === 2) break; // EOS

                    // Update the NEXT position in the buffer with the prediction
                    if (currentIdx + 1 < MAX_LEN) {
                        tokenBuffer[currentIdx + 1] = bestIdx;
                    }
                    currentIdx++;

                    if (bestIdx > 3) decodedStr += (VOCAB_DATA.target_idx2char[bestIdx] || "");
                }
                return decodedStr;

            } catch (e) {
                console.error("Error processing " + word, e);
                return "Error";
            }
        }
        // --- PIPELINE ---
        async function runPipeline() {
            const sentence = document.getElementById('inputText').value;
            if (!sentence || !encSession) return;

            const container = document.getElementById('breakdownContainer');
            const showSyllables = document.getElementById('sylToggle').checked;
            container.innerHTML = "";
            document.getElementById('finalOutput').innerText = "...";

            const words = tokenizeWords(sentence);
            const finalResults = [];

            for (let word of words) {
                const thaiWord = await transliterateWord(word);
                finalResults.push(thaiWord);

                const wordBlock = document.createElement('div');
                wordBlock.className = 'word-block';
                
                let middleContent = "";
                if (showSyllables) {
                    const syllables = tokenizeSyllables(word);
                    middleContent = `<div style="margin:4px 0">${syllables.map(s => `<span class="syllable">${s}</span>`).join('')}</div>`;
                }

                wordBlock.innerHTML = `<div style="font-weight:600;color:#666">${word}</div>${middleContent}<div class="thai-output">${thaiWord}</div>`;
                container.appendChild(wordBlock);
            }

            document.getElementById('finalOutput').innerText = finalResults.join(' ');
        }
    </script>
</body>
</html>